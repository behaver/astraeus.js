'use strict';

/**
 * 计算力学时与世界时之差，即 ΔT = TD - UT，单位为秒
 *
 * 世界时（UT），即格林威治地方时，它基于地球的自转。
 * 然而，地球自转一直在变缓，而且变缓规律难以预测，这使得世界时成了一种不均匀的时间系统。
 * 
 * 历书时(ET)，它由力学定律定义：基于行星运动。
 * 1984年，ET被力学时取代，它由原子钟定义。事实上，力学时是历书时的一个延伸。
 * 它是一个均匀的时间标尺，被天文学家们用来精确计算天体力学、轨道和星历等。
 *
 * 力学时又分为太阳系质心力学时（TDB）和地心力学时（TDT）。
 * 这两个系统最多相差0.0017秒，此种差异与地球以椭圆轨道绕日运动有关(相对论效应)。
 * 因这一差异小到可以被大多数实际应用忽略，故此处我们对质心力学时和地球力学时不加区分，统称为力学时(TD)。
 *
 * 若需要某一特定时刻的 ΔT，则需要使用插值法。
 * 插值法包括 线性插值、二次插值、三次插值、拉格朗日插值法 等多种
 * 这里使用 三次插值法 的 R函数，以及相应的 插值表。
 * 
 * 本函数求得的数值为 近似 差值，力学时和世界时之间的 精确 差值 ΔT = TD - UT 只能由天文观测值推算。
 * 
 * 除了 1871 - 1901 年，世界时总是落后于相同数值的力学时。所以该段时间之外的年份，函数的结果都是正值。
 *
 * 关于计算误差，可以参照 NASA 的 https://eclipse.gsfc.nasa.gov/SEcat5/deltat.html
 *
 * 本函数参考 许剑伟 先生的寿星万年历程序，特此申明。
 *
 * @author 董 三碗 <qianxing@yeah.net>
 * @author 许 剑伟
 *
 * @param  {Number} year 需计算 ΔT 的年份，合法值域[-4000, 6000]
 * @return {Number}      返回 力学时与世界时之差，即 ΔT ，单位为秒。
 */
function UTDelay(year) {

  if (typeof(year) !== 'number') throw Error('Illegality Param.');
  if (year < -4000) throw Error('The param year must >= -4000');

	const table = [
    [ -4000, 108371.7, -13036.8, 392,0 ],
    [ -500, 17201, -627.82, 16.17, -0.3413 ],
    [ -150, 12200.6, -346.41, 5.403, -0.1593],
    [ 150, 9113.8, -328.13, -1.647, 0.0377],
    [ 500, 5707.5, -391.41, 0.915, 0.3145],
    [ 900, 2203.4, -283.45, 13.034, -0.1778],
    [ 1300, 490.1, -57.35, 2.085, -0.0072],
    [ 1600, 120, -9.81, -1.532, 0.1403],
    [ 1700, 10.2, -0.91, 0.51, -0.037],
    [ 1800, 13.4, -0.72, 0.202, -0.0193],
    [ 1830, 7.8, -1.81, 0.416, -0.0247],
    [ 1860, 8.3, -0.13, -0.406, 0.0292],
    [ 1880, -5.4, 0.32, -0.183, 0.0173],
    [ 1900, -2.3, 2.06, 0.169, -0.0135],
    [ 1920, 21.2, 1.69, -0.304, 0.0167],
    [ 1940, 24.2, 1.22, -0.064, 0.0031],
    [ 1960, 33.2, 0.51, 0.231, -0.0109],
    [ 1980, 51, 1.29, -0.026, 0.0032],
    [ 2000, 63.87, 0.3345, -0.0604, 0.0017 ],
    [ 2050, ],
  ];
  
  let i;

  if (year >= 2050) {
    let jsd = 31; // jsd是y1年之后的加速度估计。瑞士星历表jsd=31,NASA网站jsd=32,skmap的jsd=29
    let ext = function(y, jsd) {
      let dy = (y - 1820) / 100;
      return -20 + jsd * dy * dy;
    };

    if (year > 2150) return ext(year, jsd);
    else {
      let v = ext(year, jsd); // 二次曲线外推
      let dv = ext(2050, jsd) - 69; // ye年的二次外推与te的差
      return v - dv * (2150 - year) / 100;
    }
  }

  // 遍历出的 i 为 Table 索引
  for (i = 0; i < table.length - 1 && year > table[i][0]; i++);

  let t1 = (year - table[i - 1][0]) / (table[i][0] - table[i - 1][0]) * 10,
      t2 = t1 * t1,
      t3 = t2 * t1;
  let res = table[i - 1][1] + table[i - 1][2] * t1 + table[i - 1][3] * t2 + table[i - 1][4] * t3;
  return res;
}

module.exports = UTDelay;
